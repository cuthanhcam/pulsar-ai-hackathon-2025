/**
 * Parse Markdown course content into structured data
 * Handles AI-generated Markdown and converts to DB format
 */

export interface ParsedSection {
  title: string
  content: string // Raw markdown content
  duration: number
  order: number
}

export interface ParsedModule {
  title: string
  description: string
  sections: ParsedSection[]
  order: number
}

export interface ParsedCourse {
  title: string
  description: string
  modules: ParsedModule[]
}

/**
 * Parse Markdown course content generated by AI
 * Expected format:
 * 
 * # Course Title
 * Course description
 * 
 * ## Module 1: Title
 * Module description
 * 
 * ### Section 1.1: Title
 * [Duration: 10 minutes]
 * Section content...
 * 
 * ### Section 1.2: Title
 * ...
 */
export function parseMarkdownCourse(markdown: string): ParsedCourse {
  const lines = markdown.split('\n')
  
  let courseTitle = ''
  let courseDescription = ''
  const modules: ParsedModule[] = []
  
  let currentModule: ParsedModule | null = null
  let currentSection: ParsedSection | null = null
  let currentContent: string[] = []
  
  let mode: 'title' | 'description' | 'module' | 'section' = 'title'
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]
    
    // Course title (# Title)
    if (line.startsWith('# ') && !courseTitle) {
      courseTitle = line.substring(2).trim()
      mode = 'description'
      continue
    }
    
    // Module header (## Module N: Title)
    if (line.startsWith('## ')) {
      // Save previous section if exists
      if (currentSection && currentModule) {
        currentSection.content = currentContent.join('\n').trim()
        currentModule.sections.push(currentSection)
        currentContent = []
      }
      
      // Save previous module if exists
      if (currentModule) {
        modules.push(currentModule)
      }
      
      // Parse module title
      const moduleTitle = line.substring(3).trim()
      const moduleMatch = moduleTitle.match(/Module\s+(\d+):\s*(.+)/)
      
      currentModule = {
        title: moduleMatch ? moduleMatch[2] : moduleTitle,
        description: '',
        sections: [],
        order: moduleMatch ? parseInt(moduleMatch[1]) : modules.length + 1
      }
      
      mode = 'module'
      continue
    }
    
    // Section header (### Section N.M: Title or ### Title)
    if (line.startsWith('### ')) {
      // Save previous section if exists
      if (currentSection && currentModule) {
        currentSection.content = currentContent.join('\n').trim()
        currentModule.sections.push(currentSection)
        currentContent = []
      }
      
      // Parse section title
      const sectionTitle = line.substring(4).trim()
      
      currentSection = {
        title: sectionTitle,
        content: '',
        duration: 10, // Default, will be updated if found
        order: currentModule ? currentModule.sections.length + 1 : 1
      }
      
      mode = 'section'
      continue
    }
    
    // Duration marker [Duration: X minutes] or Duration: X minutes
    if (line.includes('Duration:') || line.includes('Thời gian:') || line.includes('duration:')) {
      const durationMatch = line.match(/(\d+)[-\s]*(phút|minutes?|mins?)/i)
      if (durationMatch && currentSection) {
        currentSection.duration = parseInt(durationMatch[1])
      }
      continue
    }
    
    // Skip horizontal rules (---, ___, ***)
    if (line.trim().match(/^[-_*]{3,}$/)) {
      continue
    }
    
    // Content lines
    if (mode === 'description' && !currentModule) {
      if (line.trim()) {
        courseDescription += line + '\n'
      }
    } else if (mode === 'module' && currentModule && !currentSection) {
      // Module description (lines after ## before first ###)
      if (line.trim()) {
        currentModule.description += line + '\n'
      }
    } else if (mode === 'section' && currentSection) {
      // Section content
      currentContent.push(line)
    }
  }
  
  // Save last section
  if (currentSection && currentModule) {
    currentSection.content = currentContent.join('\n').trim()
    currentModule.sections.push(currentSection)
  }
  
  // Save last module
  if (currentModule) {
    modules.push(currentModule)
  }
  
  // Clean up descriptions
  courseDescription = courseDescription.trim()
  modules.forEach(m => {
    m.description = m.description.trim()
  })
  
  return {
    title: courseTitle || 'Untitled Course',
    description: courseDescription || 'No description provided',
    modules
  }
}

/**
 * Validate parsed course structure
 * FLEXIBLE: Accept any number of modules/sections, just ensure basic structure exists
 * NEW: Sections can be empty (content generated on-demand later)
 */
export function validateParsedCourse(course: ParsedCourse): { valid: boolean; errors: string[] } {
  const errors: string[] = []
  const warnings: string[] = []
  
  if (!course.title) {
    errors.push('Course title is missing')
  }
  
  if (!course.modules || course.modules.length === 0) {
    errors.push('No modules found')
  }
  
  let totalSections = 0
  let sectionsWithContent = 0
  
  course.modules.forEach((module, moduleIndex) => {
    if (!module.title) {
      errors.push(`Module ${moduleIndex + 1} has no title`)
    }
    
    if (!module.sections || module.sections.length === 0) {
      warnings.push(`Module ${moduleIndex + 1} "${module.title}" has no sections`)
    } else {
      totalSections += module.sections.length
      
      module.sections.forEach((section, sectionIndex) => {
        if (!section.title) {
          warnings.push(`Module ${moduleIndex + 1}, Section ${sectionIndex + 1} has no title`)
        }
        
        // NEW: Content is optional now (generated on-demand)
        if (section.content && section.content.length >= 50) {
          sectionsWithContent++
        }
        // Don't warn about empty content - it's expected!
      })
    }
  })
  
  console.log('[Parser] Validation summary:', {
    modules: course.modules.length,
    totalSections,
    sectionsWithContent,
    sectionsWithoutContent: totalSections - sectionsWithContent,
    errorsCount: errors.length,
    warningsCount: warnings.length
  })
  
  if (warnings.length > 0) {
    console.log('[Parser] Warnings:', warnings)
  }
  
  // Only fail if critical errors (no title, no modules, no sections with titles)
  return {
    valid: errors.length === 0 && totalSections > 0,
    errors: [...errors, ...warnings]
  }
}
